<!DOCTYPE html>
<html><head>
<meta charset="utf-8"/>
<title>Ultra-30× Heavy GPU Torture</title>
<style>
  body{margin:0;background:#000;color:#0f0;font-family:monospace}
  canvas{width:100vw;height:100vh;display:block}
  #info{position:fixed;top:6px;left:6px;font-size:10px}
</style>
</head><body>
<canvas id="c"></canvas>
<pre id="info">Loading…</pre>

<script>
const c=document.getElementById('c');
const gl=c.getContext('webgl2',{antialias:false,preserveDrawingBuffer:false});
if(!gl){alert('WebGL2 required');}

const info=document.getElementById('info');
let frame=0,lastT=0,fps=0;

function resize(){
  const d=devicePixelRatio;
  c.width=3840*d;   // 4K render
  c.height=2160*d;
  gl.viewport(0,0,c.width,c.height);
}
window.onresize=resize;
resize();

/* ---------- Vertex shader ---------- */
const vs=`#version 300 es
in vec2 p;
void main(){gl_Position=vec4(p,0.,1.);}`;

/* ---------- 30× HEAVY Fragment shader ---------- */
const fs=`#version 300 es
precision highp float;
out vec4 O;
uniform vec2 R;
uniform float T;

/* 64-bit PRNG */
uvec2 hash(uvec2 x){
    x+=x.yx*vec2(443897987.,981729233.);
    x^=x.yx>>11u;
    x+=x.yx*vec2(553242253.,1526732657.);
    x^=x.yx>>16u;
    return x;
}
float rand(vec2 co){
    uvec2 h=hash(floatBitsToUint(co));
    return float(h.x+h.y)*2.3283064365386963e-10;
}

/* 32-octave fBM */
float fbm(vec3 p){
    float v=0.;
    float w=1.;
    for(int i=0;i<32;i++){
        v+=w*noise(p);   // noise() inline below
        p*=2.;
        w*=.5;
    }
    return v;
}
float noise(vec3 p){
    vec3 i=floor(p),f=fract(p);
    return mix(mix(mix(rand(i),rand(i+vec3(1,0,0)),f.x),
                   mix(rand(i+vec3(0,1,0)),rand(i+vec3(1,1,0)),f.x),f.y),
               mix(mix(rand(i+vec3(0,0,1)),rand(i+vec3(1,0,1)),f.x),
                   mix(rand(i+vec3(0,1,1)),rand(i+vec3(1,1,1)),f.x),f.y),f.z);
}

/* Quadruple fractal field */
float map(vec3 q){
    float d=1e20;

    /* 1) Menger sponge (5 iter) */
    vec3 w=q;
    for(int i=0;i<5;i++){
        w=abs(w)-.5;
        w*=3.;
        w.xz*=mat2(cos(T*.2),sin(T*.2),-sin(T*.2),cos(T*.2));
        float k=max(abs(w.x),max(abs(w.y),abs(w.z)));
        w-=clamp(w,-k,k)*2.;
        d=min(d,length(w)-.03);
    }

    /* 2) Mandelbulb (power 9) */
    w=q;
    float dr=1.,r=0.;
    for(int i=0;i<12;i++){
        r=length(w);
        if(r>2.) break;
        float theta=acos(w.z/r);
        float phi=atan(w.y,w.x);
        dr=pow(r,8.)*9.*dr+1.;
        w=pow(r,9.)*vec3(sin(theta*9.)*cos(phi*9.),sin(theta*9.)*sin(phi*9.),cos(theta*9.))+q;
    }
    d=min(d,0.5*log(r)*r/dr);

    /* 3) Kaleidoscopic IFS (7 iter) */
    w=q;
    for(int i=0;i<7;i++){
        w=abs(w);
        if(w.x+w.y<0.) w=vec3(-w.y,-w.x,w.z);
        if(w.x<0.) w=vec3(-w.x,w.y,w.z);
        if(w.y<0.) w=vec3(w.x,-w.y,w.z);
        w*=1.8;
        w-=vec3(1,1,1);
    }
    d=min(d,length(w)-.06);

    /* 4) Quaternion Julia */
    vec4 z=vec4(q,0.);
    vec4 c=vec4(.3,.5,.7,.2);
    for(int i=0;i<15;i++){
        z=vec4(z.x*z.x-dot(z.yzw,z.yzw),2.*z.x*z.yzw)+c;
        if(dot(z,z)>4.) break;
    }
    d=min(d,length(z.xyz)-.08);

    /* Volumetric fBM displacement */
    d+=fbm(q*4.)*.2;
    return d;
}

/* Pathtracing (2-bounce) */
vec3 render(vec3 ro,vec3 rd){
    vec3 col=vec3(0),mask=vec3(1);
    for(int b=0;b<2;b++){
        float t=0.;
        /* 16 384 steps */
        for(int i=0;i<16384;i++){
            vec3 p=ro+rd*t;
            float d=map(p);
            if(d<.0005){
                vec3 n=normalize(vec3(map(p+vec3(.0005,0,0)),
                                      map(p+vec3(0,.0005,0)),
                                      map(p+vec3(0,0,.0005)))-d);
                vec3 l=normalize(vec3(2,3,-1));
                vec3 h=normalize(l-rd);
                vec3 diff=vec3(.9,.7,1.)*max(0.,dot(n,l));
                vec3 spec=vec3(1)*pow(max(0.,dot(n,h)),64.);
                col+=mask*(diff+spec*.5)*exp(-t*.04);
                mask*=vec3(.7);
                ro=p+n*.002;
                rd=reflect(rd,n);
                break;
            }
            t+=max(d*.015,.0005);
            if(t>50.) break;
        }
    }
    return col;
}

void main(){
    vec2 uv=(gl_FragCoord.xy*2.-R.xy)/min(R.x,R.y);
    vec3 col=vec3(0);
    /* 16×16 SSAA = 256 samples */
    for(int sx=0;sx<16;sx++)
    for(int sy=0;sy<16;sy++){
        vec2 off=(vec2(float(sx),float(sy))-7.5)/16.;
        vec2 suv=uv+off/R.yy;
        float tm=T*.05;
        vec3 ro=vec3(cos(tm*1.8)*6.,sin(tm*1.2)*3.,-9.+cos(tm*.9)*4.);
        vec3 ta=vec3(0);
        vec3 cf=normalize(ta-ro);
        vec3 cp=vec3(0,1,0);
        vec3 cu=normalize(cross(cp,cf));
        vec3 cv=cross(cf,cu);
        vec3 rd=normalize(suv.x*cu+suv.y*cv+cf*1.6);
        col+=render(ro,rd);
    }
    col*=1./256.;
    col=col/(1.+col);
    O=vec4(col,1);
}`;
/* ---------- Boiler-plate ---------- */
function compile(type,src){
  const s=gl.createShader(type);
  gl.shaderSource(s,src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s);
  return s;
}
const prog=gl.createProgram();
gl.attachShader(prog,compile(gl.VERTEX_SHADER,vs));
gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,fs));
gl.linkProgram(prog);
gl.useProgram(prog);

const buf=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,buf);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),gl.STATIC_DRAW);
const locP=gl.getAttribLocation(prog,'p');
gl.enableVertexAttribArray(locP);
gl.vertexAttribPointer(locP,2,gl.FLOAT,false,0,0);
const locR=gl.getUniformLocation(prog,'R');
const locT=gl.getUniformLocation(prog,'T');

/* ---------- Render loop ---------- */
function draw(t){
  frame++;
  if(t-lastT>1000){fps=frame*1000/(t-lastT);frame=0;lastT=t;
    info.textContent=`FPS: ${fps.toFixed(2)}  |  Time: ${(t*1e-3).toFixed(1)} s`;
  }
  gl.uniform2f(locR,c.width,c.height);
  gl.uniform1f(locT,t*1e-3);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);
</script>
</body></html>
