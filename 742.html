<!DOCTYPE html>
<html><head>
<meta charset="utf-8"/>
<title>1080p Death Fast</title>
<style>
  body{margin:0;background:#000;color:#0f0;font:12px monospace}
  canvas{width:100vw;height:100vh;display:block}
  #info{position:fixed;top:4px;left:4px}
</style></head><body>
<canvas id="c"></canvas>
<pre id="info">Loadingâ€¦</pre>

<script>
const c=document.getElementById('c');
const gl=c.getContext('webgl2',{antialias:false});
const info=document.getElementById('info');
if(!gl){info.textContent='WebGL2 unavailable';throw 0;}

function resize(){
  c.width=1920;
  c.height=1080;
  gl.viewport(0,0,c.width,c.height);
}
resize();

const vs=`#version 300 es
in vec2 p;
void main(){gl_Position=vec4(p,0.,1.);}`;

const fs=`#version 300 es
precision highp float;
out vec4 O;
uniform float T;
#define STEPS 8192
float map(vec3 q){
    float d=1e20;
    for(int i=0;i<5;i++){
        q=abs(q)-.6;q*=3.2;
        d=min(d,length(q)-.03);
    }
    return d;
}
vec3 render(vec3 ro,vec3 rd){
    vec3 col=vec3(0);
    for(int i=0;i<STEPS;i++){
        vec3 p=ro+rd*float(i)*.005;
        float d=map(p);
        if(d<.001){col=vec3(1);break;}
    }
    return col;
}
void main(){
    vec2 uv=(gl_FragCoord.xy*2.-vec2(1920,1080))/1080.;
    vec3 ro=vec3(0,0,-4);
    vec3 rd=normalize(vec3(uv,1));
    vec3 col=vec3(0);
    for(int sx=0;sx<16;sx++)
    for(int sy=0;sy<16;sy++){
        vec2 off=(vec2(sx-7.5)/16.)/1080.;
        col+=render(ro,normalize(vec3(uv+off,1)));
    }
    col/=256.;
    O=vec4(col,1);
}`;

const prog=gl.createProgram();
function compile(type,src){
  const s=gl.createShader(type);
  gl.shaderSource(s,src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){
    info.textContent='Shader compile error:\n'+gl.getShaderInfoLog(s);
    throw 0;
  }
  return s;
}
try{
  gl.attachShader(prog,compile(gl.VERTEX_SHADER,vs));
  gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,fs));
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog,gl.LINK_STATUS)){
    info.textContent='Link error:\n'+gl.getProgramInfoLog(prog);
    throw 0;
  }
}catch(e){}

gl.useProgram(prog);
const buf=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,buf);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),gl.STATIC_DRAW);
const locP=gl.getAttribLocation(prog,'p');
gl.enableVertexAttribArray(locP);
gl.vertexAttribPointer(locP,2,gl.FLOAT,false,0,0);
const locT=gl.getUniformLocation(prog,'T');

let frame=0,lastT=0;
function draw(t){
  frame++;
  if(t-lastT>1000){
    info.textContent=`FPS: ${(frame/(t-lastT)*1000).toFixed(3)}`;
    frame=0;lastT=t;
  }
  gl.uniform1f(locT,t*1e-3);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);
</script>
</body></html>
